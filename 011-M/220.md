Deep Indigo Whale

medium

# RioLRTAssetRegistry.sol#_normalizeDecimals function causes unnecessary rounding error.

## Summary
When we convert units through `RioLRTAssetRegistry.sol#_normalizeDecimals` function, rounding errors are generated by unnecessary division operations.

## Vulnerability Detail
`RioLRTAssetRegistry.sol#convertToUnitOfAccountFromAsset` function is the following.
```solidity
    function convertToUnitOfAccountFromAsset(address asset, uint256 amount) public view returns (uint256) {
        if (asset == ETH_ADDRESS) {
            return amount;
        }
        address priceFeed = assetInfo[asset].priceFeed;
        uint256 price = getPrice(priceFeed);

195:    return _normalizeDecimals(price * amount / priceScale, assetInfo[asset].decimals, priceFeedDecimals);
    }
```
`L195` calls the following `_normalizeDecimals` function to convert units.
```solidity
    function _normalizeDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {
        // No adjustment needed if decimals are the same.
        if (fromDecimals == toDecimals) {
            return amount;
        }
        // Scale down to match the target decimal precision.
        if (fromDecimals > toDecimals) {
            return amount / 10 ** (fromDecimals - toDecimals);
        }
        // Scale up to match the target decimal precision.
377:    return amount * 10 ** (toDecimals - fromDecimals);
    }
```
When `priceFeeDecimals > assetInfo[asset].decimals` in `L195`, `priceScale = 10 ** priceFeedDecimals` holds true. So `priceScale` is unnecessarily divided and multiplied again during unit conversion.

Example:
1. Assume that `assetInfo[asset].decimals = 2`, `priceFeedDecimals = 3`, `amount = 150`, `price = 990` on `L195`.
2. Then `priceScale = 10 ** 3 = 1000` and `amount = 990 * 150 / 1000 = 148` holds true in `_normalizeDecimals` function.
3. Since `fromDecimals = 2 < toDecimals = 3`, the return value will be `148 * 10 ** (3 - 2) = 1480` in `L377`.
4. If we calculate the return value by `price * amount / (10 ** assetInfo[asset].decimals)` in `L195`, then `990 * 150 / (10 ** 2) = 1485` holds. Therefore, it is clear that the depositor suffers a loss of `5`.

## Impact
By unnecessary rounding error, depositor will receive smaller amount of `reETH` than it should be.
Also gas is consumed unnecessarily.
The same problem exists in `RioLRTAssetRegistry.sol#convertFromUnitOfAccountToAsset` function too.

## Code Snippet
https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTAssetRegistry.sol#L195
https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTAssetRegistry.sol#L209

## Tool used
Manual Review

## Recommendation
Modify `RioLRTAssetRegistry.sol#convertToUnitOfAccountFromAsset` function as follows.
```solidity
    function convertToUnitOfAccountFromAsset(address asset, uint256 amount) public view returns (uint256) {
        if (asset == ETH_ADDRESS) {
            return amount;
        }
        address priceFeed = assetInfo[asset].priceFeed;
        uint256 price = getPrice(priceFeed);

--      return _normalizeDecimals(price * amount / priceScale, assetInfo[asset].decimals, priceFeedDecimals);
++      return price * amount / (10 ** assetInfo[asset].decimals);
```
Modify `RioLRTAssetRegistry.sol#convertToUnitOfAccountFromAsset` function as follows.
```solidity
    function convertFromUnitOfAccountToAsset(address asset, uint256 value) public view returns (uint256) {
        if (asset == ETH_ADDRESS) {
            return value;
        }
        address priceFeed = assetInfo[asset].priceFeed;
        uint256 price = getPrice(priceFeed);

--      return _normalizeDecimals(value * priceScale / price, priceFeedDecimals, assetInfo[asset].decimals);
++      return value * priceScale / (10 ** priceFeedDecimals);
    }
```
Remove the unnecessary `RioLRTAssetRegistry.sol#_normalizeDecimals` function.